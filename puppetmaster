#!/usr/bin/env ruby

'''
==INTRODUCTION==
This script is meant to be run by munin and has to be symlinked as puppet_client.
It reports the following 4 metrics:
 * Total known clients to the puppetmaster, this can include old and retired hosts
 * The total amount of unique clients that had their configuration compiled in the last 24 hours
 * The total amount of uniquw clients that had their configuration compiled in the last 5 minutes
   * The average compilation time of those configs

Like any munin plugin, this script has 2 commandline options, config and autoconfig.

==HISTORY==
21-04-2011 - Big rewrite, script can now be called in two ways, for total number or known nodes,
 and for the nodes and compile times for the last 5 _and_ 30 minutes.
17-04-2011 - Altered the handling of the "last 5 minutes" logs. It now uses Time instead of a regex
15-04-2011 - Initial release
14-04-2011 - Time handling bugfixes
13-04-2011 - This plugin is based on another plugin on munin exchange[1] by "ohadlevy@gmail.com". 

==REQUIREMENTS==
 * Ruby(tested on 1.8.6)

==COPYRIGHT==
The original plugin did not contain any copyright information, assuming public domain.
Copyright Pieter Lexis - Kumina B.V. (pieter@kumina.nl)
This script is licenced under the GNU GPL version 3 or higher

[1] - http://exchange.munin-monitoring.org/plugins/puppetmaster/details
'''
require 'time'

puppet_node = /puppet_node.?$/
puppet_total = /puppet_total.?$/
t = Time.now

def parselogs(since, count_unique=false)
  # Assuming puppetmaster logs to syslog and it does not logrotate more than once every 24 hours
  # TODO write syslog handling code to use the logs between 24 hours ago and now pseudo-code:
  # logfiles =["#{logfile}"]
  # logfile.{1,{2..X}.gz}.each do |file|
  #  top_line = [FIRST LINE OF file]
  #  logfiles.add("#{logfile}")
  #  if Time.parse(top_line[0..14] > since
  #   [BREAK FROM each]
  #  end

  # setup regex to extract compilation times
  regexp = ".* for (.*) in (.*) seconds"
  logfile = ENV["puppet_logs"] || "/var/log/syslog"
  logfiles = ["#{logfile}", "#{logfile}.1"]
  count = 0

  if count_unique
    hosts = Array.new
  else
    total = 0
  end

  logfiles.each do |logfile|
    File.open(logfile).grep(/Compiled configuration|Compiled catalog/).each do |line|
      if count_unique and Time.parse(line[0..14]) > since and line =~ /#{regexp}/
        unless hosts.include($1)
          hosts << $1
          count += 1
        end
      elsif not count_unique and Time.parse(line[0..14]) > since and line =~ /#{regexp}/
        total += $2.to_f
        count += 1
      end
    end
  end

  if count_unique
    return count
  else
    return count, total
  end

end

def count_total
  return Dir.entries('/var/lib/puppet/yaml/facts/').size-2
end

case $0
when puppet_node
  num_minutes = ENV["num_minutes"] || "5,30"
  num_minutes = num_minutes.split(/,/)
  case ARGV[0]
  when "config"
    puts "graph_title Puppet nodeconfigs"
    puts "graph_vlabel clients"
    num_minutes.each do |num_minute|
      puts "last#{num_minute}m_count.label Amount of config compilations in the last #{num_minute} minutes"
      puts "last#{num_minute}m_compile_avg.label Average compile time for all nodes in the last #{num_minute} minutes"
    end
    puts "graph_category puppet"
  when "autoconf"
    puts "yes"
  else # we were called with no or a non-sensical parameter
    num_minutes.each do |num_minute|
      count, total = parselogs(t - (60 * num_minute.to_i))
      puts "last#{num_minute}m_count.value #{count}"
      puts "last#{num_minute}m_compile_avg.value #{(total / count).to_s[0..3]}" unless count == 0
    end
  end

when puppet_total
  case ARGV[0]
  when "config"
    puts "graph_title Puppet total nodes"
    puts "graph_vlabel clients"
    puts "known_clients.label Total number of known clients"
    puts "last24h_unique_count.label unique clients in the last 24 hours"
  when "autoconf"
    puts "yes"
  else
    t24h = t - (60 * 60 * 24)
    puts "known_clients.value #{count_total()}"
    puts "last24h_unique_count.value #{parselogs(t24h, true)}"
  end
end
puts "."

# vim: shiftwidth=2:
# vim: smarttab:
# vim: expandtab:
